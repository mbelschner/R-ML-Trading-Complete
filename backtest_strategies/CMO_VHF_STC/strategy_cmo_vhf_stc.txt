//@version=5
strategy("CMO-VHF-STC Strategie", overlay=true, pyramiding=3, initial_capital=300, default_qty_type=strategy.fixed, default_qty_value=1.2)

// ============================================================================
// PARAMETER - ENTRY SIGNALS
// ============================================================================

cmo_period = input.int(14, "CMO Period", minval=1, group="Entry Indicators")
cmo_threshold = input.float(20, "CMO Threshold", minval=0, group="Entry Indicators")

vhf_period = input.int(28, "VHF Period", minval=1, group="Entry Indicators")
vhf_threshold = input.float(0.35, "VHF Threshold (Trending)", minval=0, group="Entry Indicators")

stc_fast = input.int(23, "STC Fast", minval=1, group="Entry Indicators")
stc_slow = input.int(50, "STC Slow", minval=1, group="Entry Indicators")
stc_cycle = input.int(10, "STC Cycle", minval=1, group="Entry Indicators")
stc_entry_long = input.float(25, "STC Long Entry Level", minval=0, maxval=100, group="Entry Indicators")
stc_entry_short = input.float(75, "STC Short Entry Level", minval=0, maxval=100, group="Entry Indicators")

use_price_confirmation = input.bool(true, "Preisbestätigung verwenden", group="Entry Filters")
use_adx_filter = input.bool(false, "ADX Filter verwenden", group="Entry Filters")
adx_period = input.int(14, "ADX Period", minval=1, group="Entry Filters")
adx_threshold = input.float(20, "ADX Threshold", minval=0, group="Entry Filters")

// ============================================================================
// PARAMETER - PYRAMIDING
// ============================================================================

use_pyramiding = input.bool(true, "Pyramiding aktivieren", group="Pyramiding")
pyramid_method = input.string("breakout", "Pyramiding Methode", options=["breakout", "consecutive"], group="Pyramiding")
max_pyramid_orders = input.int(3, "Max Pyramid Orders", minval=1, maxval=10, group="Pyramiding")
pyramid_spacing_atr = input.float(0.5, "Pyramid Spacing (ATR)", minval=0, group="Pyramiding")
consecutive_bars = input.int(2, "Consecutive Bars (Consecutive Methode)", minval=1, group="Pyramiding")
breakout_lookback = input.int(20, "Breakout Lookback (Breakout Methode)", minval=1, group="Pyramiding")

// ============================================================================
// PARAMETER - EXITS
// ============================================================================

exit_strategy = input.string("chandelier", "Exit Strategie", options=["chandelier", "breakeven_trailing"], group="Exit Strategy")

// Stop Loss
stop_loss_atr_mult = input.float(3.0, "Initial Stop Loss (ATR)", minval=0, group="Stop Loss")

// Chandelier Exit
chandelier_period = input.int(22, "Chandelier Period", minval=1, group="Chandelier Exit")
chandelier_multiplier = input.float(3.0, "Chandelier ATR Multiplier", minval=0, group="Chandelier Exit")

// Breakeven + Trailing
breakeven_trigger_atr = input.float(1.5, "Breakeven Trigger (ATR)", minval=0, group="Breakeven & Trailing")
breakeven_offset_atr = input.float(0.2, "Breakeven Offset (ATR)", minval=0, group="Breakeven & Trailing")
trailing_stop_atr_mult = input.float(2.0, "Trailing Stop (ATR)", minval=0, group="Breakeven & Trailing")

// Take Profit
tp_strategy = input.string("full", "Take Profit Strategie", options=["full", "partial"], group="Take Profit")
full_tp_atr_mult = input.float(4.5, "Full TP (ATR)", minval=0, group="Take Profit")

// Time Exit
close_time_hour = input.int(22, "Tägliche Close Time (Stunde)", minval=0, maxval=23, group="Time Management")

// ============================================================================
// INDIKATOREN BERECHNEN
// ============================================================================

// ATR
atr = ta.atr(14)

// CMO
cmo = ta.cmo(close, cmo_period)

// VHF
highest = ta.highest(close, vhf_period)
lowest = ta.lowest(close, vhf_period)
sum_changes = math.sum(math.abs(close - close[1]), vhf_period)
vhf = sum_changes != 0 ? (highest - lowest) / sum_changes : 0

// STC
macd_line = ta.ema(close, stc_fast) - ta.ema(close, stc_slow)
macd_min = ta.lowest(macd_line, stc_cycle)
macd_max = ta.highest(macd_line, stc_cycle)
stoch1 = macd_max != macd_min ? 100 * (macd_line - macd_min) / (macd_max - macd_min) : 50
stoch1_smooth = ta.ema(stoch1, 3)
stoch1_min = ta.lowest(stoch1_smooth, stc_cycle)
stoch1_max = ta.highest(stoch1_smooth, stc_cycle)
stc = stoch1_max != stoch1_min ? 100 * (stoch1_smooth - stoch1_min) / (stoch1_max - stoch1_min) : 50
stc_final = ta.ema(stc, 3)

// ADX (optional)
[diplus, diminus, adx_value] = ta.dmi(adx_period, adx_period)

// Chandelier Exit
chandelier_long = ta.highest(high, chandelier_period) - (chandelier_multiplier * atr)
chandelier_short = ta.lowest(low, chandelier_period) + (chandelier_multiplier * atr)

// ============================================================================
// ENTRY BEDINGUNGEN
// ============================================================================

// Setup Bedingungen
market_trending = vhf > vhf_threshold
bullish_momentum = cmo > cmo_threshold
bearish_momentum = cmo < -cmo_threshold
adx_ok = use_adx_filter ? adx_value >= adx_threshold : true
price_conf_long = use_price_confirmation ? close > close[1] : true
price_conf_short = use_price_confirmation ? close < close[1] : true

// STC Crossover
stc_cross_up = ta.crossover(stc_final, stc_entry_long)
stc_cross_down = ta.crossunder(stc_final, stc_entry_short)

// Entry Signals
longCondition = market_trending and bullish_momentum and adx_ok and price_conf_long and stc_cross_up
shortCondition = market_trending and bearish_momentum and adx_ok and price_conf_short and stc_cross_down

// ============================================================================
// PYRAMIDING BEDINGUNGEN
// ============================================================================

var int pyramid_count = 0
var float last_entry_price = na

// Breakout Pyramiding
breakout_long = use_pyramiding and pyramid_method == "breakout" and strategy.position_size > 0 and high > ta.highest(high[1], breakout_lookback)
breakout_short = use_pyramiding and pyramid_method == "breakout" and strategy.position_size < 0 and low < ta.lowest(low[1], breakout_lookback)

// Consecutive Pyramiding
consecutive_long = use_pyramiding and pyramid_method == "consecutive" and strategy.position_size > 0
consecutive_short = use_pyramiding and pyramid_method == "consecutive" and strategy.position_size < 0
for i = 1 to consecutive_bars
    consecutive_long := consecutive_long and close[i] > close[i+1]
    consecutive_short := consecutive_short and close[i] < close[i+1]

// Spacing Check
spacing_ok_long = na(last_entry_price) or close > last_entry_price + (pyramid_spacing_atr * atr)
spacing_ok_short = na(last_entry_price) or close < last_entry_price - (pyramid_spacing_atr * atr)

pyramid_long = (breakout_long or consecutive_long) and spacing_ok_long and pyramid_count < max_pyramid_orders
pyramid_short = (breakout_short or consecutive_short) and spacing_ok_short and pyramid_count < max_pyramid_orders

// ============================================================================
// EXIT BEDINGUNGEN
// ============================================================================

// Chandelier Exit
chandelier_exit_long = exit_strategy == "chandelier" and close < chandelier_long
chandelier_exit_short = exit_strategy == "chandelier" and close > chandelier_short

// Time Exit
time_exit = hour == close_time_hour

// ============================================================================
// STRATEGY EXECUTION
// ============================================================================

// Entry
if longCondition and strategy.position_size == 0
    strategy.entry("Long", strategy.long)
    pyramid_count := 1
    last_entry_price := close

if shortCondition and strategy.position_size == 0
    strategy.entry("Short", strategy.short)
    pyramid_count := 1
    last_entry_price := close

// Pyramiding
if pyramid_long
    strategy.entry("Long", strategy.long)
    pyramid_count += 1
    last_entry_price := close

if pyramid_short
    strategy.entry("Short", strategy.short)
    pyramid_count += 1
    last_entry_price := close

// Exits
if strategy.position_size > 0
    // Long Exits
    if exit_strategy == "chandelier"
        strategy.exit("Exit Long", "Long", stop=chandelier_long, limit=close + (full_tp_atr_mult * atr))
    else if exit_strategy == "breakeven_trailing"
        var float long_stop = na
        if strategy.position_avg_price + (breakeven_trigger_atr * atr) <= high
            long_stop := math.max(nz(long_stop), strategy.position_avg_price + (breakeven_offset_atr * atr))
            long_stop := math.max(nz(long_stop), high - (trailing_stop_atr_mult * atr))
        else
            long_stop := strategy.position_avg_price - (stop_loss_atr_mult * atr)
        strategy.exit("Exit Long", "Long", stop=long_stop, limit=close + (full_tp_atr_mult * atr))

if strategy.position_size < 0
    // Short Exits
    if exit_strategy == "chandelier"
        strategy.exit("Exit Short", "Short", stop=chandelier_short, limit=close - (full_tp_atr_mult * atr))
    else if exit_strategy == "breakeven_trailing"
        var float short_stop = na
        if strategy.position_avg_price - (breakeven_trigger_atr * atr) >= low
            short_stop := math.min(nz(short_stop, 999999), strategy.position_avg_price - (breakeven_offset_atr * atr))
            short_stop := math.min(nz(short_stop, 999999), low + (trailing_stop_atr_mult * atr))
        else
            short_stop := strategy.position_avg_price + (stop_loss_atr_mult * atr)
        strategy.exit("Exit Short", "Short", stop=short_stop, limit=close - (full_tp_atr_mult * atr))

// Time Exit (22:00)
if time_exit
    strategy.close_all("Time Exit 22h")
    pyramid_count := 0
    last_entry_price := na

// Reset Pyramid Count bei Position Close
if strategy.position_size == 0
    pyramid_count := 0
    last_entry_price := na

// ============================================================================
// VISUALISIERUNG
// ============================================================================

// Entry Signale
plotshape(longCondition, "Long Entry", shape.triangleup, location.belowbar, color.green, size=size.small)
plotshape(shortCondition, "Short Entry", shape.triangledown, location.abovebar, color.red, size=size.small)

// Chandelier Exit Lines
plot(exit_strategy == "chandelier" and strategy.position_size > 0 ? chandelier_long : na, "Chandelier Stop Long", color.red, linewidth=2, style=plot.style_linebr)
plot(exit_strategy == "chandelier" and strategy.position_size < 0 ? chandelier_short : na, "Chandelier Stop Short", color.red, linewidth=2, style=plot.style_linebr)

// Pyramiding Signale
plotshape(pyramid_long, "Pyramid Long", shape.diamond, location.belowbar, color.new(color.green, 50), size=size.tiny)
plotshape(pyramid_short, "Pyramid Short", shape.diamond, location.abovebar, color.new(color.red, 50), size=size.tiny)
